
ç¬¬ä¸€ç«  Djangoå’Œæ¨¡å¼
------------------   

åœ¨è¿™ä¸€ç« ï¼Œæˆ‘ä»¬è®¨è®ºä»¥ä¸‹è¯é¢˜ï¼š 

	 æˆ‘ä»¬ä¸ºä»€ä¹ˆé€‰æ‹©Djangoï¼Ÿ
	 Djangoæ˜¯å·¥ä½œåŸç†
	 ä»€ä¹ˆæ˜¯æ¨¡å¼ï¼Ÿ
	 å¸¸è§çš„æ¨¡å¼åˆé›†
	 Djangoä¸­çš„æ¨¡å¼
	

æˆ‘ä»¬ä¸ºä»€ä¹ˆé€‰æ‹©Djangoï¼Ÿ  

æ¯ä¸ªwebåº”ç”¨éƒ½ä¸å°½ç›¸åŒï¼Œå°±åƒä¸€ä»¶æ‰‹å·¥åˆ¶ä½œçš„å®¶å…·ä¸€æ ·ã€‚ä½ å‡ ä¹ä¼šå¾ˆå°‘å‘ç°å¤§æ‰¹é‡çš„ç”Ÿæˆèƒ½å¤Ÿå®Œç¾åœ°è¾¾åˆ°ä½ çš„éœ€æ±‚ã€‚å³ä½¿ä½ ä»ä¸€ä¸ªåŸºæœ¬éœ€æ±‚å¼€å§‹ï¼Œæ¯”å¦‚ä¸€ä¸ªåšå®¢æˆ–è€…ä¸€ä¸ªç¤¾äº¤ç½‘ç»œï¼Œä½ éƒ½éœ€è¦ç¼“æ…¢åœ°å¼€å‘ï¼Œ

è¿™å°±æ˜¯ç±»ä¼¼Djangoæˆ–è€…Railsçš„webæ¡†æ¶éå¸¸æµè¡Œçš„åŸå› ã€‚æ¡†æ¶åŠ é€Ÿäº†å¼€å‘ï¼Œè€Œä¸”å®ƒå¸¦æœ‰å¾ˆå¤šç»ƒå¥½çš„ç»è¿‡å®è·µçš„å†…å®¹ã€‚

Pythonå¯èƒ½æ¯”å…¶ä»–æµè¡Œçš„ç¼–ç¨‹è¯­è¨€å…·æœ‰æ›´å¤šçš„webæ¡†æ¶ã€‚

å¼€ç®±å³ç”¨çš„adminæ¥å£ï¼Œå®ƒæ˜¯Djangoæ‰æœ‰çš„ç‹¬ä¸€æ— äºŒçš„ç‰¹ç‚¹ï¼Œæ—©äº›æ—¶å€™ï¼Œç‰¹åˆ«æ˜¯åœ¨æ•°æ®è®°å½•å’Œæµ‹è¯•æ–¹é¢å®ƒå¤§æœ‰è£¨ç›Šã€‚è€ŒDjangoçš„å¼€å‘æ–‡æ¡£ä½œä¸ºä¸€ä¸ªå‡ºè‰²çš„å¼€æºé¡¹ç›®æ—©å·²æ˜¯å¤‡å—èµèª‰ã€‚

æœ€åï¼ŒDjangoåœ¨å¤šä¸ªé«˜æµé‡çš„ç½‘ç«™ä¸­å†ç»å®æˆ˜çš„è€ƒéªŒã€‚å®ƒå¯¹äºå¸¸è§çš„æ”»å‡»æ¯”å¦‚è·¨ç«™è„šæœ¬å’Œè·¨ç«™è¯·æ±‚æ”»å‡»æœ‰ç€å¼‚å¸¸æ•é”è§‚å¯Ÿã€‚

å°½ç®¡ï¼Œåœ¨ç†è®ºä¸Šï¼Œå¯èƒ½å¯¹äºæ‰€æœ‰ç±»å‹çš„ç½‘ç«™Djangoä¸æ˜¯æœ€ä½³é€‰æ‹©ï¼Œä½ å¯ä»¥æ˜¯ä½¿ç”¨Djangoæ„å»ºä»»ä½•ç±»å‹çš„ç½‘ç«™ã€‚ä¾‹å¦‚ï¼Œè¦æ„å»ºä¸€ä¸ªåŸºäºwebèŠå¤©çš„å®æ—¶æ¥å£ï¼Œæˆ–è®¸ä½ è¦ä½¿ç”¨Tornadoï¼Œä½†æ˜¯webå¼•ç”¨å‰©ä¸‹çš„éƒ¨åˆ†ä½ å¯ä»¥ä»æ—§ä½¿ç”¨Djangoæ¥å®Œæˆã€‚å¯¹äºå¼€å‘ä½ è¦å­¦ä¼šé€‰æ‹©æ­£ç¡®çš„å·¥å…·ã€‚

æŸäº›å†…å»ºçš„ç‰¹æ€§ï¼Œæ¯”å¦‚adminæ¥å£ï¼Œå¦‚æœä½ ä½¿ç”¨è¿‡å…¶ä»–çš„webæ¡†æ¶æˆ–è®¸è®©ä½ å¬ä¸Šå»æ„Ÿè§‰æœ‰ç‚¹æ€ªæ€ªçš„ã€‚ä¸ºäº†Djangoçš„è®¾è®¡ï¼Œå°±è®©æˆ‘ä»¬æ‰¾å‡ºå®ƒæ˜¯å¦‚ä½•é—®ä¸–çš„ã€‚

##Djangoçš„å†å²
When you look at the Pyramids of Egypt, you would think that such a simple and minimal design must have been quite obvious. In truth, they are products of 4,000 years of architectural evolution. Step Pyramids, the initial (and clunky) design, had six rectangular blocks of decreasing size. It took several iterations of architectural and engineering improvements until the modern, glazing, and long-lasting limestone structures were invented.  

Looking at Django you might get a similar feeling. So, elegantly built, it must have been ô°awlessly conceived. ô°šn the contrary, it was the result of rewrites and rapid iterations in one of the most high-pressure environments imaginableâ€”a newsroom!  

In the fall of 2003, two programmers, Adrian Holovaty and Simon Willison, working at the Lawrence Journal-World newspaper, were working on creating several local news websites in Kansas. These sites, including LJWorld.com, Lawrence.com, and KUsports.comâ€”like most news sites were not just content-driven portals chock-
full of text, photos, and videos, but they also constantly tried to serve the needs of the local Lawrence community with applications, such as a local business directory, events calendar, classifieds, and so on.  


###ä¸€ä¸ªæ¡†æ¶çš„è¯ç”Ÿ
This, of course, meant lots of work for Simon, Adrian, and later Jacob Kaplan Moss who had joined their team; with very short deadlines, sometimes with only a few hours' notice. Since it was the early days of web development in Python, they had to write web applications mostly from scratch. So, to save precious time, they gradually refactored out the common modules and tools into something called "The CMS."  

Eventually, the content management parts were spun off into a separate project called the Ellington CMS, which went on to become a successful commercial CMS product. The rest of "The CMS" was a neat underlying framework that was general enough to be used to build web applications of any kind.  

By July 2005, this web development framework was released as Django (pronounced Jang-Oh) under an open source Berkeley Software Distribution (BSD) license.
It was named after the legendary jazz guitarist Django Reinhardt. And the rest,
as they say, is history.  

###ç§»é™¤é­”æ³•
Due to its humble origins as an internal tool, Django had a lot of Lawrence ô°ˆournalô°ƒWorldô°ƒspecific oddities. To ô°€ake Django truly general purpose, an effort dubbed "Removing the Lawrence" was already underway.  

However, the ô°€ost significant refactoring effort that Django developers had to undertake was called "Removing the Magic." This ambitious project involved cleaning up all the warts Django had accumulated over the years, including a lot of magic (an informal term for implicit features) and replacing them with a more natural and explicit Pythonic code. For example, the model classes used to be imported from a magic module called django.models.*, rather than directly importing them from the models.py ô°€odule they were defined in.  

At that time, Django had about a hundred thousand lines of code, and it was a significant rewrite of the ô°…PI. ô°šn May ô°›, ô°œô°¤ô°¤ô°¦, these changes, alô°€ost the siô°„e of a small book, were integrated into Django's development version trunk and released as Django release ô°¤.ô°§ô°¨. This was a significant step toward the Django ô°›.ô°¤ í¯¿  í°€ilestone.

###DjangoåšæŒåšå¾—æ›´å¥½
Every year, conferences called DjangoCons are held across the world for Django developers to meet and interact with each other. They have an adorable tradition
of giving a semi-humorous keynote on "why Django sucks." This could be a member of the Django community, or someone who works on competing web frameworks or just any notable personality.  

Over the years, it is amazing how Django developers took these criticisms positively and mitigated them in subsequent releases. Here is a short summary of the improvements corresponding to what once used to be a shortcoming in Django and the release they were resolved in:  

```
â€¢ New form-handling library (Django 0.96)
â€¢ Decoupling admin from models (Django 1.0)
â€¢ Multiple database support (Django 1.2)
â€¢ Managing static files better ô°‹Django ô°›.ô°¥ô°Œ
â€¢ Better time zone support (Django 1.4)
â€¢ Customizable user model (Django 1.5)
â€¢ Better transaction handling (Django 1.6)
â€¢ Built-in database migrations (Django 1.7)
```
  

###Djangoæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ
è¦çœŸæ­£çš„æ¬£èµDjangoï¼Œä½ éœ€è¦æ’‡å¼€è¡¨è±¡æ¥çœ‹æœ¬è´¨ã€‚å®ƒå¯å‘ä½ åŒæ—¶è®©ä½ ä¸çŸ¥æ‰€æªã€‚å¦‚æœä½ å·²ç»ç†Ÿæ‚‰å®ƒï¼Œæˆ–è®¸å°±æƒ³è¦è·³è¿‡è¿™ä¸€èŠ‚ã€‚

ä¸‹å›¾ï¼šåœ¨ä¸€ä¸ªå…¸å‹çš„Djangoåº”ç”¨ä¸­webè¯·æ±‚æ˜¯å¦‚ä½•è¢«å¤„ç†çš„ã€‚  
![django request](http://ww1.sinaimg.cn/mw1024/6184c0e3gw1ertof4w7ckj20m50d8dhi.jpg)

å‰é¢çš„å›¾ç‰‡å±•ç¤ºäº†ä»ä¸€ä¸ªè®¿å®¢çš„æµè§ˆå™¨åˆ°Djangoåº”ç”¨å¹¶è¿”å›çš„ä¸€ä¸ªwebè¯·æ±‚çš„ç®€å•å†ç¨‹ã€‚å¦‚ä¸‹æ˜¯æ•°å­—æ ‡è¯†çš„è·¯å¾„ï¼š

	1. æµè§ˆå™¨å‘é€è¯·æ±‚ï¼ˆåŸºæœ¬ä¸Šæ˜¯å­—èŠ‚ç±»å‹çš„å­—ç¬¦ä¸²ï¼‰åˆ°webæœåŠ¡å™¨ã€‚
	
	2. webæœåŠ¡å™¨ï¼ˆæ¯”å¦‚ï¼ŒNginxï¼‰æŠŠè¿™ä¸ªè¯·æ±‚è½¬äº¤åˆ°ä¸€ä¸ªWSGIï¼ˆæ¯”å¦‚ï¼ŒuWSGIï¼‰ï¼Œæˆ–è€…ç›´æ¥åœ°æ–‡ä»¶ç³»ç»Ÿèƒ½å¤Ÿå–å‡º
	ä¸€ä¸ªæ–‡ä»¶ï¼ˆæ¯”å¦‚ï¼Œä¸€ä¸ªCSSæ–‡ä»¶ï¼‰ã€‚
	
	3. ä¸åƒwebæœåŠ¡å™¨é‚£æ ·ï¼ŒWSGIæœåŠ¡å™¨å¯ä»¥ç›´æ¥è¿è¡ŒPythonåº”ç”¨ã€‚è¯·æ±‚ç”Ÿæˆä¸€ä¸ªè¢«ç§°ä¸ºenvironçš„Ptyhonå­—å…¸ï¼Œ
	è€Œä¸”ï¼Œå¯ä»¥é€‰æ‹©ä¼ é€’è¿‡å»å‡ ä¸ªä¸­é—´ä»¶çš„å±‚ï¼Œæœ€ç»ˆï¼Œè¾¾åˆ°Djangoåº”ç”¨ã€‚
	
	4. URLconfä¸­å«æœ‰å±äºåº”ç”¨çš„urls.pyé€‰æ‹©ä¸€ä¸ªè§†å›¾å¤„ç†åŸºäºè¯·æ±‚çš„URLçš„é‚£ä¸ªè¯·æ±‚ï¼Œè¿™ä¸ªè¯·æ±‚å°±å·²ç»å˜æˆäº†
	HttpRequestâ€”â€”ä¸€ä¸ªPythonå­—å…¸å¯¹è±¡ã€‚
	
	5. è¢«é€‰æ‹©çš„é‚£ä¸ªè§†å›¾é€šå¸¸è¦åšä¸‹é¢æ‰€åˆ—å‡ºçš„ä¸€ä»¶æˆ–è€…æ›´å¤šä»¶äº‹æƒ…ï¼š 
	
	   é€šè¿‡æ¨¡å‹ä¸æ•°æ®åº“å¯¹è¯ã€‚
	   ä½¿ç”¨æ¨¡æ¿æ¸²æŸ“HTMLæˆ–è€…ä»»ä½•æ ¼å¼åŒ–è¿‡çš„å“åº”ã€‚
	   è¿”å›ä¸€ä¸ªçº¯æ–‡æœ¬å“åº”ï¼ˆä¸è¢«æ˜¾ç¤ºçš„ï¼‰ã€‚
	   æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ã€‚
	   
	6. HttpResponseå¯¹è±¡ç¦»å¼€Djangoåï¼Œè¢«æ¸²æŸ“ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ã€‚
	
	7. åœ¨æµè§ˆå™¨è§åˆ°ä¸€ä¸ªç¾åŒ–çš„ï¼Œæ¸²æŸ“åçš„webé¡µé¢ã€‚
	

è™½ç„¶æŸäº›ç»†èŠ‚è¢«çœç•¥æ‰ï¼Œè¿™ä¸ªè§£é‡Šåº”è¯¥æœ‰åŠ©äºæ¬£èµDjangoçš„é«˜çº§æ¶æ„ã€‚å®ƒä¹Ÿå±•ç¤ºäº†å…³é”®çš„ç»„ä»¶æ‰€æ‰®æ¼”çš„è§’è‰²ï¼Œæ¯”å¦‚æ¨¡å‹ï¼Œè§†å›¾ï¼Œå’Œæ¨¡æ¿ã€‚Djangoçš„å¾ˆå¤šç»„ä»¶éƒ½åŸºäºè¿™å‡ ä¸ªå¹¿ä¸ºäººçŸ¥è®¾è®¡æ¨¡å¼ã€‚  

##ä»€ä¹ˆæ˜¯æ¨¡å¼ï¼Ÿ
What is coô°€ô°€on between the words ô°‡Blueprint,ô°‡ ô°‡ô°†caffolding,ô°‡ and ô°‡Maintenanceô°‡? These software development terms have been borrowed from the world of building construction and architecture. However, one of the ô°€ost inô°uential terô°€s coô°€es from a treatise on architecture and urban planning written in 1977 by the leading Austrian architect Christopher Alexander and his team consisting of Murray Silverstein, Sara Ishikawa, and several others.  

The term "Pattern" came in vogue after their seminal work, A Pattern Language: Towns, Buildings, Construction ô°‹voluô°€e ô°œ in a fiveô°ƒbook seriesô°Œ based on the astonishing insight that users know about their buildings more than any architect ever could. A pattern refers to an everyday problem and its proposed but time-tested solution.  

In the book, Christopher Alexander states that "Each pattern describes a problem, which occurs over and over again in our environment, and then describes the core of the solution to that problem in such a way that you can use this solution
a million times over, without ever doing it the same way twice."  

For example, the Wings Of Light pattern describes how people prefer buildings with more natural lighting and suggests arranging the building so that it is composed of wings. These wings should be long and narrow, never more than 25 feet wide. Next time you enjoy a stroll through the long well-lit corridors of an old university, be grateful to this pattern.  

Their book contained 253 such practical patterns, from the design of a room to the design of entire cities. Most importantly, each of these patterns gave a name to an abstract problem and together formed a pattern language.  

Reô°€eô°€ber when you first caô°€e across the word dÃ©jÃ  vu? You probably thought "Wow, I never knew that there was a word for that experience." Similarly, architects were not only able to identify patterns in their environô°€ent but could also, finally, name them in a way that their peers could understand.  

In the world of software, the term design pattern refers to a general repeatable solution to a commonly occurring problem in software design. It is a formalization of best practices that a developer can use. Like in the world of architecture, the pattern language has proven to be extremely helpful to communicate a certain way of solving a design problem to other programmers.  

There are several collections of design patterns but some have been considerably ô°€ore inô°uential than the others.  
  
###å››äººç»„æ¨¡å¼
One of the earliest efforts to study and document design patterns was a book
titled Design Patterns: Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, who later became known as the Gang of Four (GoF). This book is so inô°uential that ô°€any consider the ô°œô°¥ design patterns in the book as fundamental to software engineering itself.  

In reality, the patterns were written primarily for object-oriented programming languages, and it had code examples in C++ and Smalltalk. As we will see shortly, many of these patterns might not be even required in other programming languages with better higher-order abstractions such as Python.  

The ô°œô°¥ patterns have been broadly classified by their type as followsô°‚ï¼š  

```
â€¢ Creational Patterns: These include Abstract Factory, Builder Pattern, Factory Method, Prototype Pattern, and Singleton Pattern
â€¢ Structural Patterns: These include Adapter Pattern, Bridge Pattern, Composite Pattern, Decorator Pattern, Facade Pattern, Flyweight Pattern, and Proxy Pattern
â€¢ Behavioral Patterns: These include Chain of Responsibility, Command Pattern, Interpreter Pattern, Iterator Pattern, Mediator Pattern, Memento Pattern, Observer Pattern, State Pattern, Strategy Pattern, Template Pattern, and Visitor Pattern
```
  
While a detailed explanation of each pattern would be beyond the scope of this book, it would be interesting to identify some of these patterns in Django itself:  

Djangoä¸­çš„æ¨¡å¼ä¸æ­¤å¯¹æ¯”ï¼š 

|å››äººç»„æ¨¡å¼		|Djangoç»„ä»¶		|		è§£é‡Š					|
| ------------- |:-------------:|----------------------:|
|å‘½ä»¤æ¨¡å¼        |HttpRequest    |æŠŠä¸€ä¸ªrequestå°è£…è¿›ä¸€ä¸ªå¯¹è±¡
|è§‚å¯Ÿè€…æ¨¡å¼		|Signals		|ä¸€ä¸ªå¯¹è±¡æ”¹å˜çŠ¶æ€æ—¶ï¼Œå®ƒçš„æ‰€æœ‰ä¾¦å¬å™¨éƒ½è¢«é€šçŸ¥å¹¶è‡ªåŠ¨æ›´æ–°
|æ¨¡æ¿æ¨¡å¼		|åŸºäºç±»çš„è§†å›¾		| ä¸€ä¸ªç®—æ³•çš„æ­¥éª¤å¯ä»¥ä¸ç”¨æ”¹å˜ç®—æ³•ç»“æ„æ¥é‡æ–°å®šä¹‰å­ç±»

è€Œè¿™äº›æ¨¡å¼æ˜¯å¯¹äºå­¦ä¹ Djangoå†…éƒ¨çš„äººæ¥è¯´æ„é€ æœ€æœ‰è¶£çš„ï¼ŒDjangoä¸‹é¢çš„æ¨¡å¼å¯ä»¥å†æ¬¡åˆ†ç±»â€”â€”è¿™ä¹Ÿæ˜¯ä¸ªå¸¸è§çš„é—®é¢˜ã€‚

###Djangoæ˜¯MVCå—ï¼Ÿ
Model-View-Controller (MVC) is an architectural pattern invented by Xerox PARC in the 70s. Being the framework used to build user interfaces in Smalltalk, it gets an early mention in the GoF book.  

Today, MVC is a very popular pattern in web application frameworks. Beginners often ask the questionô°©is Django an Mô°Šô°– fraô°€ework?  

The answer is both yes and no. The MVC pattern advocates the decoupling of
the presentation layer from the application logic. For instance, while designing
an online game website API, you might present a game's high scores table as an HTML, ô°ªML, or coô°€ô°€aô°ƒseparated ô°‹ô°–ô°†ô°Šô°Œ file. However, its underlying ô°€odel class would be designed independent of how the data would be finally presented.
MVC is very rigid about what models, views, and controllers do. However, Django takes a much more practical view to web applications. Due to the nature of the HTTP protocol, each request for a web page is independent of any other request. Django's framework is designed like a pipeline to process each request and prepare a response.  

Django calls this the Model-Template-View (MTV) architecture. There is separation of concerns between the database interfacing classes (Model), request-processing classes ô°‹ô°Šiewô°Œ, and a teô°€plating language for the final presentation ô°‹Teô°€plateô°Œ.
  
If you compare this with the classic MVCâ€”"Model" is comparable to Django's Models, "View" is usually Django's Templates, and "Controller" is the framework itself that processes an incoming HTTP request and routes it to the correct view function.  

If this has not confused you enough, Django prefers to name the callback function to handle each URL a "view" function. This is, unfortunately, not related to the MVC pattern's idea of a View.  

MVCå¯¹äºæ¨¡å‹ï¼Œè§†å›¾ï¼Œå’Œæ§åˆ¶è¯¥åšä»€ä¹ˆè®¾å®šçš„éå¸¸ä¸¥æ ¼ã€‚ç„¶è€Œï¼Œåˆ°webåº”ç”¨Djangoé‡‡å–çš„æ˜¯æ›´å®ç”¨çš„è§†å›¾ã€‚è¦å¤„ç†åŸç”Ÿçš„HTTPåè®®ï¼Œæ¯ä¸ªåˆ°webé¡µé¢çš„è¯·æ±‚ç‹¬ç«‹äºå…¶ä»–çš„è¯·æ±‚ã€‚Djangoçš„æ¡†æ¶è®¾è®¡çš„åƒä¸€ä¸ªç®¡é“å¤„ç†æ¯ä¸ªè¯·æ±‚ï¼Œå‡†å¤‡å¥½å“åº”ã€‚  

Djangoç§°ä¹‹ä¸ºæ¨¡å‹-æ¨¡æ¿-è§†å›¾ï¼ˆMTVï¼‰æ¶æ„ã€‚æ•°æ®åº“æ¥å£ç±»ï¼ˆæ¨¡å‹ï¼‰å’Œ è¯·æ±‚å¤„ç†ç±»ï¼ˆè§†å›¾ï¼‰ï¼Œä»¥åŠæœ€ç»ˆè¡¨ç°çš„æ¨¡æ¿è¯­è¨€ä¹‹é—´æœ‰ç€ç‹¬ç«‹å…³ç³»ã€‚  

å¦‚æœä½ å°†å®ƒäºç»å…¸çš„MVCæ¯”è¾ƒï¼Œâ€œæ¨¡å‹â€å¯ä»¥é€šDjangoçš„æ¨¡å‹æ¯”è¾ƒï¼Œâ€œè§†å›¾â€  

è¦æ˜¯è¿™äº›éƒ½è¿˜ä¸è¶³ä»¥è®©ä½ æ„Ÿåˆ°è¿·æƒ‘ï¼ŒDjangoå€¾å‘äºé€‰æ‹©å‘½åå›è°ƒå‡½æ•°å¤„ç†æ¯ä¸ªURLçš„â€œè§†å›¾â€å‡½æ•°ã€‚å³ï¼Œä¸€ä¸ªæ²¡æœ‰MVCè§†å›¾æ¦‚å¿µçš„è§†å›¾ã€‚

###ç¦å‹’æ¨¡å¼
In 2002, Martin Fowler wrote Patterns of Enterprise Application Architecture, which described 40 or so patterns he often encountered while building enterprise applications.  

Unlike the GoF book, which described design patterns, Fowler's book was about architectural patterns. Hence, they describe patterns at a much higher level of abstraction and are largely programming language agnostic.
Fowler's patterns are organized as follows:  

```
â€¢ Domain Logic Patterns: These include Domain Model, Transaction Script, Service Layer , and Table Module
â€¢ Data Source Architectural Patterns: These include Row Data Gateway, Table Data Gateway, Data Mapper, and Active Record
â€¢ Object-Relational Behavioral Patterns: These include Identity Map, Unit of Work, and Lazy Load
â€¢ Object-Relational Structural Patterns: These include Foreign Key Mapping, Mapping, Dependent Mapping, Association Table Mapping, Identity
Field, Serialized LOB, Embedded Value, Inheritance Mappers, Single Table Inheritance, Concrete Table Inheritance, and Class Table Inheritance
â€¢ Object-Relational Metadata Mapping Patterns: These include Query Object, Metadata Mapping, and Repository
â€¢ Web Presentation Patterns: These include Page Controller, Front Controller, Model View Controller, Transform View, Template View, Application Controller, and Two-Step View
â€¢ Distribution Patterns: These include Data Transfer Object and Remote Facade
â€¢ Offline Concurrency Patterns: These include Coarse Grained Lock, Implicit Lock, Optimistic ô°šfô°ine Lock, and Pessiô°€istic ô°šfô°ine Lock
â€¢ Session State Patterns: These include Database Session State, Client Session State, and Server Session State
â€¢ Base Patterns: These include Mapper, Gateway, Layer Supertype, Registry, Value Object, Separated Interface, Money, Plugin, Special Case, Service Stub, and Record Set
```
  
Almost all of these patterns would be useful to know while architecting a Django application. In fact, Fowler's website at http://martinfowler.com/eaaCatalog/ has an excellent catalog of these patterns. I highly recommend that you check them out.
Django also implements a number of these patterns. The following table lists a few of them:  

Djangoä¸­çš„æ¨¡å¼ä¸æ­¤å¯¹æ¯”ï¼š  

|å››äººç»„æ¨¡å¼	  	|Djangoç»„ä»¶	  	|è§£é‡Š					|
|-------------	|:-------------:|--------------------:	|
|æ´»åŠ¨è®°å½•		|Djangoæ¨¡å‹		|å°è£…æ•°æ®åº“è®¿é—®ï¼Œå¯¹æ•°æ®æ·»åŠ åŸŸåé€»è¾‘
|ç±»è¡¨ç»§æ‰¿		|æ¨¡å‹ç»§æ‰¿		|ç»§æ‰¿ä¸­çš„æ¯ä¸ªå®ä½“éƒ½æ˜ å°„åˆ°ä¸€ä¸ªç‹¬ç«‹çš„è¡¨
|æ ‡è¯†è‡ªåŠ¨		|Idå­—æ®µ			|åœ¨ä¸€ä¸ªå¯¹è±¡ä¸­ä¿å­˜ä¸€ä¸ªæ•°æ®åº“IDå­—æ®µä»¥ç»´æŠ¤æ ‡è¯†
|æ¨¡æ¿è§†å›¾		|Djangoæ¨¡æ¿ 		|ä½¿ç”¨HTMLçš„å†…åµŒç”Ÿæˆå™¨æ¸²æŸ“åˆ°HTML


###è¿˜æœ‰æ›´å¤šçš„æ¨¡å¼ï¼Ÿ
Yes, of course. Patterns are discovered all the tiô°€e. Like living beings, soô°€e mutate and form new patterns: take, for instance, MVC variants such as Modelâ€“viewâ€“presenter (MVP), Hierarchical modelâ€“viewâ€“controller (HMVC), or Model View ViewModel (MVVM).  

Patterns also evolve with tiô°€e as better solutions to known probleô°€s are identified. For example, Singleton pattern was once considered to be a design pattern but now is considered to be an Anti-pattern due to the shared state it introduces, similar to using global variables. An Anti-pattern can be defined as coô°€ô°€only reinvented but a bad solution to a problem.  
  
Some of the other well-known books which catalog patterns are Pattern-Oriented Software Architecture (known as POSA) by Buschmann, Meunier, Rohnert, Sommerlad, and Sta; Enterprise Integration Patterns by Hohpe and Woolf; and
The Design of Sites: Patterns, Principles, and Processes for Crafting a Customer-Centered Web Experience by Duyne, Landay, and Hong.  


##æœ¬ä¹¦ä¸­æ¨¡å¼
This book will cover Djangoô°ƒspecific design and architecture patterns, which would be useful to a Django developer. The upcoming sections will describe how each pattern will be presented.  

*Pattern name*
The heading is the pattern name. If it is a well-known pattern, the commonly used name is used; otherwise, a terse, self-descriptive name has been chosen. Names are important, as they help in building the pattern vocabulary. All patterns will have the following parts:  
*Problem*:ô°‚ This brieô°y ô°€entions the probleô°€.
  
*Solution*: This summarizes the proposed solution(s).
  

*Problem Details*: This elaborates the context of the problem and possibly gives an example.
*Solution Details*: This explains the solution(s) in general terms and provides a sample Django implementation.

æœ¬ä¹¦è¦†ç›–é’ˆå¯¹å¯¹äºDjangoå¼€å‘è€…ä¼šå¾ˆæœ‰ç”¨çš„Djangoçš„è®¾è®¡å’Œæ¶æ„æ¨¡å¼ã€‚æ¥ä¸‹æ¥çš„ç« èŠ‚ä¼šæè¿°æ¯ä¸ªæ¨¡å¼æ˜¯å¦‚ä½•å®ç°çš„ã€‚

**æ¨¡å¼åç§°**
æ ‡é¢˜æ˜¯æ¨¡å¼åç§°ã€‚å¦‚æœå®ƒæ˜¯çŸ¥åçš„æ¨¡å¼ï¼Œå¸¸ç”¨çš„åå­—è¢«ä½¿ç”¨ï¼›å¦åˆ™ï¼Œç®€æ´çš„ï¼Œè‡ªæè¿°çš„åç§°è¢«é€‰æ‹©ã€‚åç§°éå¸¸é‡è¦ï¼Œå®ƒä»¬æœ‰åŠ©äºæ„å»ºæ¨¡å¼è¯æ±‡ã€‚æ‰€æœ‰çš„æ¨¡å¼éƒ½æœ‰ä»¥ä¸‹éƒ¨åˆ†ï¼š  

###é‰´å®¡æ¨¡å¼
Despite their near universal usage, Patterns have their share of criticism too. The most common arguments against them are as follows:  

```
â€¢ Patterns compensate for the missing language features: Peter Norvig found that 16 of the 23 patterns in Design Patterns were 'invisible or simpler' in Lisp. Considering Python's introspective facilities and firstô°ƒclass functions, this ô°€ight as well be the case for Python too.
â€¢ Patterns repeat best practices: Many patterns are essentially formalizations of best practices such as separation of concerns and could seem redundant.
â€¢ Patterns can lead to over-engineering: Implementing the pattern might be less efficient and excessive coô°€pared to a siô°€pler solution.

```
å°½ç®¡å®ƒä»¬è¿‘ä¹äºé€šç”¨ï¼Œæ¨¡å¼å…±äº«ä¹Ÿæœ‰å®ƒä»¬çš„å®¡é‰´å…±äº«ã€‚å®ƒä»¬çš„æœ€å¸¸è§å‚æ•°å¦‚ä¸‹ï¼š  
ç•¥

###å¦‚ä½•ä½¿ç”¨æ¨¡å¼  
While some of the previous criticisms are quite valid, they are based on how patterns are misused. Here is some advice that can help you understand how best to use design patterns:
  
```
â€¢ Don't implement a pattern if your language supports a direct solution
â€¢ Don't try to retroô°ƒfit everything in terô°€s of patterns
â€¢ Use a pattern only if it is the most elegant solution in your context
â€¢ Don't be afraid to create new patterns
```

>####æœ€ä½³å®è·µ  
In addition to design patterns, there might be a recommended approach to solving a problem. In Django, as with Python, there might be several ways to solve a problem but one idiomatic approach among those.  


###Pythonä¹‹ç¦…å’ŒDjangoçš„è®¾è®¡å“²å­¦  
Generally, the Python community uses the term 'Pythonic' to describe a piece of idiomatic code. It typically refers to the principles laid out in 'The Zen of Python'. Written like a poem, it is extremely useful to describe such a vague concept.
  
>Try entering import this in a Python prompt to view 'The Zen of Python'.  

Furthermore, Django developers have crisply documented their design philosophies while designing the framework at https://docs.djangoproject.com/en/dev/ misc/design-philosophies/.  

While the document describes the thought process behind how Django was designed, it is also useful for developers using Django to build applications. Certain principles such as Don't Repeat Yourself (DRY), loose coupling, and tight cohesion can help you write more maintainable and idiomatic Django applications.  

Django or Python best practices suggested by this book would be formatted in the following manner:
  
>#####Best Practice:
Use BASE_DIR in settings.py and avoid hard-coding directory names.  

>####æœ€ä½³å®è·µï¼š  
åœ¨settings.pyä¸­ä½¿ç”¨BASE_DIRï¼Œé¿å…ç¡¬ç¼–ç ç›®å½•åç§°ã€‚  

##æ€»ç»“  
In this chapter, we looked at why people choose Django over other web frameworks, its interesting history, and how it works. We also examined design patterns, popular pattern collections, and best practices.  

In the next chapter, we will take a look at the first few steps in the beginning of a Django project such as gathering requirements, creating mockups, and setting up the project.  



